<!--
 * @Author: Dongzy
 * @since: 2020-01-14 19:06:13
 * @lastTime     : 2020-01-14 21:02:51
 * @LastAuthor   : Dongzy
 * @文件相对于项目的路径: \DailyInterviewQuestion\Answer\Vue\vue是如何对数组方法进行变异的.md
 * @message:
 -->

# vue 是如何对数组方法进行变异的

这个的本质还是在双向数据绑定的时候，对数组的七个方法重写`push、pop、shift、unshift、splice、sort、reverse`
在这些方法添加修改的没有双向数据绑定的时候，将其元素进行绑定

## 起

判断当前双向绑定的数据是否为数组，如果是,再判是否浏览器支持**proto**属性，如果支持泽直接覆盖对象原型中的方法，不支持就直接覆盖数组
将数组取出来后将其绑定上 arrayMethods 方法，再遍历数组，将其中每个值调用 observe 进一步深度判断

## 承

arrayMethods 方法，
这里不用 flow 的类型控制，因为其在数组原型上的的动态类型工作的很好

首先取得原生数组的原型，再将其使用 Object.create。新建一个对象，防止污染其他方法。

之后遍历其中`push、pop、shift、unshift、splice、sort、reverse`，这些方法，将其原生方法，绑定在其中。
然后针对其中的传参，提交至将要执行的函数，然后将其处理后的数据进行双向数据绑定.同时在 dep.notify
通知所有订阅者进行响应式处理。

> 从数组的原型新建一个 Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持**proto**这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。如果没有该属性的浏览器，则必须通过遍历 def 所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。

在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行 observe。

但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置 length 来修改数组，可以通过 Vue.set 以及 splice 方法。这两个方法进行更新
